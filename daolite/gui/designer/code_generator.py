"""
Code generator for the daolite pipeline designer.

This module generates executable Python code from a visual pipeline design.
"""

from typing import List, Dict, Tuple, Optional

from daolite.common import ComponentType
from .components import ComponentBlock
from daolite.compute import create_compute_resources
import datetime


class CodeGenerator:
    """
    Generates executable Python code from pipeline design.

    This class analyzes the component blocks and connections in a
    pipeline design and produces executable code that creates the
    equivalent daolite pipeline.
    """

    def __init__(self, components: List[ComponentBlock]):
        """
        Initialize with a list of component blocks.

        Args:
            components: List of component blocks in the pipeline
        """
        self.components = components
        self.import_statements = set(
            [
                "import numpy as np",
                "from daolite import Pipeline, PipelineComponent, ComponentType",
            ]
        )
        
        # Add transfer components between components on different resources
        self.generated_transfer_components = []
        self._add_transfer_components()

    def generate_code(self, pipeline_title=None) -> str:
        """
        Generate executable Python code for the pipeline.

        Args:
            pipeline_title: Optional title for the pipeline visualization

        Returns:
            str: Python code that creates the designed pipeline
        """
        code_parts = []
        preamble = self._add_pramble()
        code_parts.append(preamble)
        # Generate import statements
        self._add_required_imports()
        imports = "\n".join(sorted(self.import_statements))
        code_parts.append(imports)
        code_parts.append("")  # Empty line

        # Generate pipeline creation
        code_parts.append("# Create a pipeline")
        code_parts.append("pipeline = Pipeline()")
        code_parts.append("")  # Empty line

        # Generate component code in dependency order
        ordered_components = self._sort_components_by_dependencies()
        for component in ordered_components:
            code_parts.append(self._generate_component_code(component))
            code_parts.append("")  # Empty line

        # Generate code to run the pipeline
        code_parts.append("# Run the pipeline")
        code_parts.append("timing_results = pipeline.run(debug=True)")
        code_parts.append("")

        # Generate visualization code
        code_parts.append("# Visualize the pipeline timing")
        if pipeline_title:
            code_parts.append(f'pipeline.visualize(')
            code_parts.append(f'    title="{pipeline_title}",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")
        else:
            code_parts.append('pipeline.visualize(')
            code_parts.append('    title="AO Pipeline Timing",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")

        return "\n".join(code_parts)

    def _add_pramble(self):
        """Add a comment at the top of the generated code."""
        preamble = f"#**************************************************************************\n"
        preamble += f"# This code was generated by the daolite pipeline designer\n"
        preamble += f"# Edits to this code may be lost if the pipeline is re-exported\n"
        preamble += f"# Please use the daolite pipeline designer to make changes\n"
        preamble += f"# Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        preamble += f"#**************************************************************************\n\n"
        return preamble

    def _add_required_imports(self):
        """Add required import statements based on component types."""
        # Add imports for compute resources
        self.import_statements.add(
            "from daolite.compute import create_compute_resources"
        )
        
        # ALWAYS add hardware import - it's required for standard compute resources
        self.import_statements.add(
            "from daolite.compute import hardware"
        )
        
        # Track which camera functions are used
        used_camera_funcs = set()
        for component in self.components:
            if component.component_type == ComponentType.CAMERA:
                camera_func = component.params.get("camera_function", "PCOCamLink")
                used_camera_funcs.add(camera_func)
                
        if used_camera_funcs:
            cam_imports = ", ".join(sorted(used_camera_funcs))
            self.import_statements.add(
                f"from daolite.simulation.camera import {cam_imports}"
            )

        # Remove any import of simulate_camera_readout
        self.import_statements = {
            imp
            for imp in self.import_statements
            if "simulate_camera_readout" not in imp
        }

        # Check for component types and add relevant imports
        has_network = False
        for component in self.components:
            # Add component-specific imports
            if component.component_type == ComponentType.CENTROIDER:
                self.import_statements.add(
                    "from daolite.pipeline.centroider import Centroider"
                )

            elif component.component_type == ComponentType.RECONSTRUCTION:
                self.import_statements.add(
                    "from daolite.pipeline.reconstruction import Reconstruction"
                )

            elif component.component_type == ComponentType.CONTROL:
                self.import_statements.add(
                    "from daolite.pipeline.control import FullFrameControl"
                )

            elif component.component_type == ComponentType.CALIBRATION:
                self.import_statements.add(
                    "from daolite.pipeline.calibration import PixelCalibration"
                )

            elif component.component_type == ComponentType.NETWORK:
                has_network = True

        # For visualization
        self.import_statements.add("import matplotlib.pyplot as plt")

        # Add imports for transfer functions
        has_network = False
        has_pcie = False
        for component in self.components:
            if component.component_type == ComponentType.NETWORK:
                transfer_type = component.params.get("transfer_type", "").lower()
                if transfer_type == "pcie":
                    has_pcie = True
                elif transfer_type == "network":
                    has_network = True
        for transfer in getattr(self, 'generated_transfer_components', []):
            ttype = transfer.get('transfer_type', '').lower()
            if ttype == 'pcie':
                has_pcie = True
            elif ttype == 'network':
                has_network = True
        if has_network:
            self.import_statements.add("from daolite.utils.network import network_transfer")
        if has_pcie:
            self.import_statements.add("from daolite.utils.network import pcie_transfer")

    def _generate_component_code(self, component: ComponentBlock) -> str:
        """
        Generate code for a specific component.

        Args:
            component: Component block to generate code for

        Returns:
            str: Python code for adding this component to the pipeline
        """
        lines = []

        # Skip generating code for synthetic components that aren't meant to be in the output
        if hasattr(component, '_is_synthetic') and component._is_synthetic:
            return ""

        # Check if this is a transfer component created by the designer
        is_transfer = False
        transfer_data = None
        # Special handling for generated transfer components
        if (component.component_type == ComponentType.NETWORK and 
            component.name.startswith(("Network_Transfer_", "PCIe_Transfer_"))):
            is_transfer = True
            # Find this component in our generated transfer list
            for transfer in self.generated_transfer_components:
                if transfer["name"] == component.name:
                    transfer_data = transfer
                    break

        # Add comment
        lines.append(
            f"# Add {component.name} component ({component.component_type.value})"
        )

        # Add component creation code
        lines.append(f"pipeline.add_component(PipelineComponent(")
        lines.append(
            f"    component_type=ComponentType.{component.component_type.name},"
        )
        lines.append(f'    name="{component.name}",')

        # Add compute resource
        compute_resource = component.get_compute_resource()
        if compute_resource:
            # Try to get a readable name for the compute resource
            compute_code = self._get_compute_resource_code(component)
            lines.append(f"    compute={compute_code},")
        else:
            # Use default values for all required arguments
            lines.append(
                "    compute=create_compute_resources("
                "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
                "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
                "network_speed=100e9, time_in_driver=5.0),"
            )

        # Add function name based on component type
        function_name = self._get_function_name_for_component(component)
        # Camera: use selected camera simulation function
        if component.component_type == ComponentType.CAMERA:
            # Use a parameter or default to PCOCamLink
            camera_func = component.params.get("camera_function", "PCOCamLink")
            lines.append(f"    function={camera_func},")
        else:
            lines.append(f"    function={function_name},")

        # Add parameters
        param_lines = self._generate_params_code(component)
        # Insert params block with a trailing comma
        if param_lines:
            # Remove the last '}'
            if param_lines[-1].strip() == "}":
                param_lines[-1] = "},"
            lines.extend([f"    {param_line}" for param_line in param_lines])

        # Add dependencies
        # For generated transfer components, get dependencies from the transfer data
        if is_transfer and transfer_data and "dependencies" in transfer_data:
            dependencies = transfer_data["dependencies"]
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(f"DEBUG: Generated transfer component {component.name} with dependencies from transfer data: {dependencies}")
            else:
                lines.append(f"    dependencies=[]  # No dependencies")
                print(f"DEBUG: Generated transfer component {component.name} with NO dependencies from transfer data")
        else:
            dependencies = self._get_component_dependencies(component)
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(f"DEBUG: Generated component {component.name} with dependencies: {dependencies}")
            else:
                lines.append(f"    dependencies=[]  # No dependencies")
                print(f"DEBUG: Generated component {component.name} with NO dependencies")

        # Close the function call
        lines.append("))")

        return "\n".join(lines)

    def _get_function_name_for_component(self, component: ComponentBlock) -> str:
        """Get the appropriate function name based on component type."""
        if component.component_type == ComponentType.CAMERA:
            return "simulate_camera_readout"
        elif component.component_type == ComponentType.CENTROIDER:
            return "Centroider"
        elif component.component_type == ComponentType.RECONSTRUCTION:
            return "Reconstruction"
        elif component.component_type == ComponentType.CONTROL:
            return "FullFrameControl"
        elif component.component_type == ComponentType.CALIBRATION:
            return "PixelCalibration"
        elif component.component_type == ComponentType.NETWORK:
            # Check if this is an auto-generated transfer component
            if hasattr(component, 'params') and 'transfer_type' in component.params:
                transfer_type = component.params['transfer_type'].lower()
                if transfer_type == 'pcie':
                    return "pcie_transfer"
                elif transfer_type == 'network':
                    return "network_transfer"
            # Default to network_transfer for user-created network components
            return "network_transfer"
        else:
            return "unknown_function"  # Default

    def _get_compute_resource_code(self, component: ComponentBlock) -> str:
        """
        Get code for the component's compute resource.
        
        Args:
            component: The component block
            
        Returns:
            str: Python code for the compute resource
        """
        compute_resource = component.get_compute_resource()
        if compute_resource:
            c = compute_resource
            resource_name = getattr(c, 'name', '').lower() if hasattr(c, 'name') else ''
            # Use new hardware resource loader: check for YAML-based hardware resource
            import os
            hardware_dir = os.path.join(os.path.dirname(__file__), '../../compute/hardware')
            if resource_name:
                yaml_path = os.path.join(hardware_dir, f'{resource_name}.yaml')
                if os.path.exists(yaml_path):
                    self.import_statements.add("from daolite.compute import hardware")
                    return f"hardware.{resource_name}()"
            # Fallback to explicit resource fields if not a known YAML hardware
            return (
                f"create_compute_resources("
                f"cores={getattr(c, 'cores', 16)}, "
                f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                f"memory_width={getattr(c, 'memory_width', 64)}, "
                f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
            )
        # Try to get parent container compute resource
        parent = getattr(component, 'parentItem', lambda: None)()
        if parent and hasattr(parent, 'get_compute_resource'):
            c = parent.get_compute_resource()
            if c:
                resource_name = getattr(c, 'name', '').lower() if hasattr(c, 'name') else ''
                import os
                hardware_dir = os.path.join(os.path.dirname(__file__), '../../compute/hardware')
                if resource_name:
                    yaml_path = os.path.join(hardware_dir, f'{resource_name}.yaml')
                    if os.path.exists(yaml_path):
                        self.import_statements.add("from daolite.compute import hardware")
                        return f"hardware.{resource_name}()"
                return (
                    f"create_compute_resources("
                    f"cores={getattr(c, 'cores', 16)}, "
                    f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                    f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                    f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                    f"memory_width={getattr(c, 'memory_width', 64)}, "
                    f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                    f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                    f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
                )
        # Fallback to default
        return (
            "create_compute_resources("
            "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
            "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
            "network_speed=100e9, time_in_driver=5.0)"
        )

    def _generate_params_code(self, component: ComponentBlock) -> List[str]:
        lines = []
        lines.append("params={")
        # --- Use json_runner.py logic for parameter defaults ---
        # CAMERA
        if component.component_type == ComponentType.CAMERA:
            camera_func = component.params.get("camera_function", "PCOCamLink")
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP camera')
            lines.append(f'    "group": {group},  # Default packet count (was group_size)')
        # CALIBRATION
        elif component.component_type == ComponentType.CALIBRATION:
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP sensor')
            lines.append(f'    "group": {group},  # Default group size')
        # CENTROIDER
        elif component.component_type == ComponentType.CENTROIDER:
            n_valid_subaps = component.params.get("n_valid_subaps", 6400)
            n_pix_per_subap = component.params.get("n_pix_per_subap", 16)
            group = component.params.get("group", 50)
            lines.append(f'    "n_valid_subaps": {n_valid_subaps},  # 80x80')
            lines.append(f'    "n_pix_per_subap": {n_pix_per_subap},  # 16 pixels per subap')
            lines.append(f'    "group": {group},  # Default group size')
        # Add custom parameters from component, skipping those already added
        already = {"n_pixels", "group", "n_valid_subaps", "n_pix_per_subap"}
        # Process remaining parameters
        processed_params = {}
        for key, value in component.params.items():
            if key in already:
                continue
                
            # Handle parameter renaming for Centroider components
            if component.component_type == ComponentType.CENTROIDER:
                # Handle centroid_agenda parameter renaming for compatibility with function signature
                if key == "centroid_agenda":
                    key = "agenda"  # Use the correct parameter name expected by the Centroider function
                # Skip centroid_agenda_path as it's not needed and would cause an error
                elif key == "centroid_agenda_path":
                    continue
            
            # Handle parameter renaming for Reconstruction components
            elif component.component_type == ComponentType.RECONSTRUCTION:
                # Handle centroid_agenda parameter renaming for compatibility with function signature
                if key == "centroid_agenda":
                    key = "agenda"  # Use the correct parameter name expected by the Reconstruction function
                # Skip centroid_agenda_path as it's not needed and would cause an error
                elif key == "centroid_agenda_path":
                    continue
            
            processed_params[key] = value
            
        # Add processed parameters to the lines
        for key, value in processed_params.items():
            if isinstance(value, str):
                lines.append(f'    "{key}": "{value}",')
            else:
                lines.append(f'    "{key}": {value},')
        lines.append("}")
        return lines

    def _sort_components_by_dependencies(self) -> List[ComponentBlock]:
        """
        Sort components in dependency order.

        Returns a list of components where all dependencies come before
        the components that depend on them. Also includes auto-generated transfer components
        at the appropriate places in the dependency chain.

        Returns:
            List[ComponentBlock]: Sorted components including transfer components
        """
        # Create a name-to-component mapping
        comp_map = {comp.name: comp for comp in self.components}
        
        # Create synthetic ComponentBlock objects for all transfer components
        transfer_blocks = []
        for transfer in self.generated_transfer_components:
            # Create a synthetic ComponentBlock for the transfer
            transfer_block = ComponentBlock(
                ComponentType.NETWORK,
                transfer["name"]
            )
            # Set parameters from the transfer dict
            transfer_block.params = transfer["params"].copy()
            
            # Instead of setting _dependencies attribute directly, 
            # we'll use _modified_dependencies which is just for code generation
            src_comp = transfer.get("src_comp")
            dest_comp = transfer.get("dest_comp")
            
            # Set up modified dependencies for the transfer block
            transfer_block._modified_dependencies = []
            if "dependencies" in transfer:
                transfer_block._modified_dependencies = transfer["dependencies"].copy()
            elif src_comp:
                transfer_block._modified_dependencies = [src_comp.name]
            
            # Add to the mapping - this will be used for dependency resolution
            comp_map[transfer_block.name] = transfer_block
            transfer_blocks.append(transfer_block)
            
            # Update destination component's dependencies to include this transfer
            # in the dependency graph (not in the actual component)
            if dest_comp and dest_comp.name in comp_map:
                # Create modified dependencies to replace source with transfer
                if not hasattr(dest_comp, '_modified_dependencies'):
                    # Start with original dependencies
                    dest_comp._modified_dependencies = dest_comp.get_dependencies().copy()
                    
                # Replace direct dependency on source with dependency on transfer
                if src_comp and src_comp.name in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.remove(src_comp.name)
                    # Only add if not already there
                    if transfer_block.name not in dest_comp._modified_dependencies:
                        dest_comp._modified_dependencies.append(transfer_block.name)
                elif src_comp:
                    # If dest doesn't have explicit dependency on source, add dependency on transfer anyway
                    # This handles case where UI doesn't show the dependency but code needs it
                    if transfer_block.name not in dest_comp._modified_dependencies:
                        dest_comp._modified_dependencies.append(transfer_block.name)
        
        # Build the dependency graph
        graph = {}
        for comp in list(self.components) + transfer_blocks:
            # Use modified dependencies if available (these account for transfer components)
            if hasattr(comp, '_modified_dependencies'):
                graph[comp.name] = set(comp._modified_dependencies)
            else:
                graph[comp.name] = set(comp.get_dependencies())
        
        # Find components with no dependencies
        no_deps = [name for name, deps in graph.items() if not deps]
        sorted_names = []

        # Topological sort
        while no_deps:
            name = no_deps.pop(0)
            sorted_names.append(name)

            # Find all components that depend on this one
            for dep_name, deps in list(graph.items()):
                if name in deps:
                    deps.remove(name)
                    # If no more dependencies, add to no_deps
                    if not deps and dep_name not in sorted_names:
                        no_deps.append(dep_name)

        # Check for circular dependencies
        if len(sorted_names) < len(graph):
            # Some components couldn't be sorted
            # Add remaining components in any order
            remaining = set(comp_map.keys()) - set(sorted_names)
            sorted_names.extend(remaining)

        # Convert back to component objects
        sorted_components = []
        for name in sorted_names:
            if name in comp_map:
                sorted_components.append(comp_map[name])
                
        return sorted_components

    def export_to_file(self, filename: str):
        """
        Export generated code to a Python file.

        Args:
            filename: Path to output file
        """
        code = self.generate_code()

        with open(filename, "w") as f:
            f.write(code)

    def _add_transfer_components(self):
        """
        Analyze component connections and add appropriate transfer components
        when connections cross different compute resources.
        
        This implements the transfer chain insertion logic:
        - GPU → GPU (different computers): PCIe (GPU1→host) → Network (host1→host2) → PCIe (host2→GPU2)
        - GPU → CPU (different computers): PCIe (GPU→host) → Network (host→host)
        - CPU → GPU (different computers): Network (host→host) → PCIe (host→GPU)
        - CPU → CPU (different computers): Network (host→host)
        - CPU ↔ GPU (same computer): PCIe (CPU↔GPU)
        - Camera → anything: Network transfer and PCIe if destination is GPU
        """
        # Get connections between components
        connections = []
        for src_comp in self.components:
            for port in src_comp.output_ports:
                for dest_comp, _ in port.connected_to:
                    connections.append((src_comp, dest_comp))
        
        # Process each connection for resource boundaries
        for src_comp, dest_comp in connections:
            src_res = src_comp.get_compute_resource()
            dest_res = dest_comp.get_compute_resource()
            
            # Helper function to determine if a component runs on a GPU
            def is_gpu(comp, res):
                # Check hardware field
                if getattr(res, 'hardware', '').lower() == 'gpu':
                    return True
                # Check parent container type
                parent = comp.parentItem() if hasattr(comp, 'parentItem') else None
                if parent and parent.__class__.__name__.lower() == 'gpubox':
                    return True
                return False
            
            # Helper to get parent ComputeBox - returns None if not found
            def get_compute_box(comp):
                parent = comp.parentItem() if hasattr(comp, 'parentItem') else None
                if parent and parent.__class__.__name__.lower() == 'computebox':
                    return parent
                if parent and parent.__class__.__name__.lower() == 'gpubox':
                    grandparent = parent.parentItem() if hasattr(parent, 'parentItem') else None
                    if grandparent and grandparent.__class__.__name__.lower() == 'computebox':
                        return grandparent
                return None
                
            # Determine component types and locations
            src_is_gpu = is_gpu(src_comp, src_res)
            dest_is_gpu = is_gpu(dest_comp, dest_res)
            src_compute_box = get_compute_box(src_comp)
            dest_compute_box = get_compute_box(dest_comp)
            different_computers = src_compute_box and dest_compute_box and src_compute_box != dest_compute_box
            
            # Create list to store the transfers in this connection
            transfer_chain = []
            
            # SPECIAL CASE: Camera components
            if src_comp.component_type == ComponentType.CAMERA:
                # Camera → anything: Always insert Network transfer
                network_transfer = self._create_transfer_component(
                    src_comp, dest_comp, "Network", 
                    host_comp=dest_comp,  # Use destination for network characteristics
                    dependencies=[src_comp.name]
                )
                transfer_chain.append(network_transfer)
                
                # If destination is GPU, also add PCIe transfer
                if dest_is_gpu:
                    # Network → PCIe chain for Camera → GPU
                    pcie_transfer = self._create_transfer_component(
                        src_comp, dest_comp, "PCIe",
                        host_comp=dest_comp,  # Use destination for PCIe characteristics
                        dependencies=[network_transfer["name"]]  # Make PCIe depend on Network
                    )
                    transfer_chain.append(pcie_transfer)
                
            # GPU → GPU (different computers)
            elif src_is_gpu and dest_is_gpu and different_computers:
                # Extract CPU (host) components for both source and destination GPUs
                src_host_comp = src_compute_box  # Using ComputeBox as host
                dest_host_comp = dest_compute_box  # Using ComputeBox as host
                
                # Create PCIe from GPU1 to host1
                pcie_src_to_host = self._create_transfer_component(
                    src_comp, None, "PCIe",
                    host_comp=src_host_comp,
                    custom_name=f"PCIe_Transfer_{src_comp.name}_to_host",
                    dependencies=[src_comp.name]
                )
                
                # Create Network from host1 to host2
                network_host_to_host = self._create_transfer_component(
                    src_host_comp, dest_host_comp, "Network",
                    custom_name=f"Network_Transfer_{src_compute_box.name}_to_{dest_compute_box.name}",
                    dependencies=[pcie_src_to_host["name"]]
                )
                
                # Create PCIe from host2 to GPU2
                pcie_host_to_dest = self._create_transfer_component(
                    None, dest_comp, "PCIe",
                    host_comp=dest_host_comp,
                    custom_name=f"PCIe_Transfer_host_to_{dest_comp.name}",
                    dependencies=[network_host_to_host["name"]]
                )
                
                transfer_chain.extend([pcie_src_to_host, network_host_to_host, pcie_host_to_dest])
                
            # GPU → CPU (different computers)
            elif src_is_gpu and not dest_is_gpu and different_computers:
                # Create PCIe from GPU to host1
                pcie_gpu_to_host = self._create_transfer_component(
                    src_comp, None, "PCIe",
                    host_comp=src_compute_box,
                    custom_name=f"PCIe_Transfer_{src_comp.name}_to_host",
                    dependencies=[src_comp.name]
                )
                
                # Create Network from host1 to host2
                network_host_to_host = self._create_transfer_component(
                    src_compute_box, dest_compute_box, "Network",
                    custom_name=f"Network_Transfer_{src_compute_box.name}_to_{dest_compute_box.name}",
                    dependencies=[pcie_gpu_to_host["name"]]
                )
                
                transfer_chain.extend([pcie_gpu_to_host, network_host_to_host])
                
            # CPU → GPU (different computers)
            elif not src_is_gpu and dest_is_gpu and different_computers:
                # Create Network from host1 to host2
                network_host_to_host = self._create_transfer_component(
                    src_comp, None, "Network",
                    host_comp=dest_compute_box,
                    custom_name=f"Network_Transfer_{src_compute_box.name}_to_{dest_compute_box.name}",
                    dependencies=[src_comp.name]
                )
                
                # Create PCIe from host2 to GPU
                pcie_host_to_gpu = self._create_transfer_component(
                    None, dest_comp, "PCIe",
                    host_comp=dest_compute_box,
                    custom_name=f"PCIe_Transfer_host_to_{dest_comp.name}",
                    dependencies=[network_host_to_host["name"]]
                )
                
                transfer_chain.extend([network_host_to_host, pcie_host_to_gpu])
                
            # CPU → CPU (different computers)
            elif not src_is_gpu and not dest_is_gpu and different_computers:
                # Create Network from host1 to host2
                network_host_to_host = self._create_transfer_component(
                    src_comp, dest_comp, "Network",
                    custom_name=f"Network_Transfer_{src_compute_box.name}_to_{dest_compute_box.name}",
                    dependencies=[src_comp.name]
                )
                
                transfer_chain.append(network_host_to_host)
                
            # CPU ↔ GPU (on same computer)
            elif src_is_gpu != dest_is_gpu and not different_computers:
                # Create PCIe transfer between CPU and GPU
                pcie_transfer = self._create_transfer_component(
                    src_comp, dest_comp, "PCIe",
                    dependencies=[src_comp.name]
                )
                
                transfer_chain.append(pcie_transfer)
            
            # Add all transfers in this chain to the generated transfers list
            if transfer_chain:
                # Set up the chain dependencies correctly
                for i, transfer in enumerate(transfer_chain):
                    # Set destination component to depend on the last transfer in the chain
                    if i == len(transfer_chain) - 1:
                        # Instead of trying to modify _dependencies directly (which might not exist),
                        # we'll use the _modified_dependencies attribute which is used only during code generation
                        # Create _modified_dependencies attribute if it doesn't exist
                        if not hasattr(dest_comp, '_modified_dependencies'):
                            dest_comp._modified_dependencies = dest_comp.get_dependencies()
                        
                        # Remove direct dependency on source if it exists
                        if src_comp.name in dest_comp._modified_dependencies:
                            dest_comp._modified_dependencies.remove(src_comp.name)
                        
                        # Add dependency on last transfer
                        if transfer["name"] not in dest_comp._modified_dependencies:
                            dest_comp._modified_dependencies.append(transfer["name"])
                    
                # Store all transfers in this chain
                self.generated_transfer_components.extend(transfer_chain)

    def _create_transfer_component(self, src_comp, dest_comp, transfer_type, 
                                   host_comp=None, custom_name=None, dependencies=None):
        """
        Create a transfer component between components.
        
        Args:
            src_comp: Source component (can be None for intermediate transfers)
            dest_comp: Destination component (can be None for intermediate transfers)
            transfer_type: "PCIe" or "Network"
            host_comp: Optional host component for resource information
            custom_name: Optional custom name for the transfer component
            dependencies: List of component names this transfer depends on
            
        Returns:
            dict: Dictionary representing the transfer component
        """
        # Add network/PCIe imports
        if transfer_type == "Network":
            self.import_statements.add("from daolite.utils.network import network_transfer")
        elif transfer_type == "PCIe":
            self.import_statements.add("from daolite.utils.network import pcie_transfer")

        # Generate a name for the transfer component if not provided
        if custom_name:
            transfer_name = custom_name
        elif src_comp and dest_comp:
            transfer_name = f"{transfer_type}_Transfer_{src_comp.name}_to_{dest_comp.name}"
        elif src_comp:
            transfer_name = f"{transfer_type}_Transfer_{src_comp.name}_to_intermediate"
        elif dest_comp:
            transfer_name = f"{transfer_type}_Transfer_intermediate_to_{dest_comp.name}"
        else:
            transfer_name = f"{transfer_type}_Transfer_intermediate"

        # Add computer number if not significant
        if transfer_name.startswith(f"{transfer_type}_Transfer_"):
            import random
            if "_to_" not in transfer_name:
                # Add random number to make name unique
                transfer_name += f"_{random.randint(1000, 9999)}"

        # Import data size estimation function
        from .data_transfer import estimate_data_size

        # Determine data size based on source and destination components
        data_size = 0
        if src_comp and dest_comp:
            data_size = estimate_data_size(src_comp, dest_comp)
        elif src_comp:
            # Estimate from source component alone - use standard function in data_transfer.py
            data_size = estimate_data_size(src_comp, None)
        elif dest_comp:
            # Estimate from destination component alone - use standard function in data_transfer.py
            data_size = estimate_data_size(None, dest_comp)
        else:
            # Default data size if both are None
            data_size = 1024 * 1024 * 8  # 1MB in bits
            
        # Ensure minimum data size
        data_size = max(data_size, 1024)

        # Create parameters dictionary
        params = {
            "n_bits": data_size,
            "transfer_type": transfer_type.lower()
        }
        
        # Add group size - use source group if available
        if src_comp and hasattr(src_comp, 'params') and 'group' in src_comp.params:
            params["group"] = src_comp.params["group"]
        elif host_comp and hasattr(host_comp, 'params') and 'group' in host_comp.params:
            params["group"] = host_comp.params["group"]
        else:
            params["group"] = 50  # Default group size
            
        # Add network-specific parameters
        if transfer_type == "Network" and host_comp:
            dest_compute = host_comp.get_compute_resource()
            if dest_compute:
                params["use_dest_network"] = True
                params["dest_network_speed"] = getattr(dest_compute, 'network_speed', 100e9)
                params["dest_time_in_driver"] = getattr(dest_compute, 'time_in_driver', 5.0)

        # Create the transfer component dictionary
        transfer_comp = {
            "name": transfer_name,
            "type": ComponentType.NETWORK,
            "src_comp": src_comp,
            "dest_comp": dest_comp,
            "transfer_type": transfer_type,
            "data_size": data_size,
            "params": params,
            "dependencies": dependencies or []
        }

        return transfer_comp
