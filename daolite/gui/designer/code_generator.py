"""
Code generator for the daolite pipeline designer.

This module generates executable Python code from a visual pipeline design.
"""

from typing import List, Dict, Tuple, Optional

from daolite.common import ComponentType
from .components import ComponentBlock
from daolite.compute import create_compute_resources
import datetime


class CodeGenerator:
    """
    Generates executable Python code from pipeline design.

    This class analyzes the component blocks and connections in a
    pipeline design and produces executable code that creates the
    equivalent daolite pipeline.
    """

    def __init__(self, components: List[ComponentBlock]):
        """
        Initialize with a list of component blocks.

        Args:
            components: List of component blocks in the pipeline
        """
        self.components = components
        self.import_statements = set(
            [
                "import numpy as np",
                "from daolite import Pipeline, PipelineComponent, ComponentType",
            ]
        )
        
        # Add transfer components between components on different resources
        self.generated_transfer_components = []
        self._add_transfer_components()

    def generate_code(self, pipeline_title=None) -> str:
        """
        Generate executable Python code for the pipeline.

        Args:
            pipeline_title: Optional title for the pipeline visualization

        Returns:
            str: Python code that creates the designed pipeline
        """
        code_parts = []
        preamble = self._add_pramble()
        code_parts.append(preamble)
        # Generate import statements
        self._add_required_imports()
        imports = "\n".join(sorted(self.import_statements))
        code_parts.append(imports)
        code_parts.append("")  # Empty line

        # Generate pipeline creation
        code_parts.append("# Create a pipeline")
        code_parts.append("pipeline = Pipeline()")
        code_parts.append("")  # Empty line

        # Generate component code in dependency order
        ordered_components = self._sort_components_by_dependencies()
        for component in ordered_components:
            code_parts.append(self._generate_component_code(component))
            code_parts.append("")  # Empty line

        # Generate code to run the pipeline
        code_parts.append("# Run the pipeline")
        code_parts.append("timing_results = pipeline.run(debug=True)")
        code_parts.append("")

        # Generate visualization code
        code_parts.append("# Visualize the pipeline timing")
        if pipeline_title:
            code_parts.append(f'pipeline.visualize(')
            code_parts.append(f'    title="{pipeline_title}",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")
        else:
            code_parts.append('pipeline.visualize(')
            code_parts.append('    title="AO Pipeline Timing",')
            code_parts.append('    save_path="ao_pipeline_timing.png"')
            code_parts.append(")")

        return "\n".join(code_parts)

    def _add_pramble(self):
        """Add a comment at the top of the generated code."""
        preamble = f"#**************************************************************************\n"
        preamble += f"# This code was generated by the daolite pipeline designer\n"
        preamble += f"# Edits to this code may be lost if the pipeline is re-exported\n"
        preamble += f"# Please use the daolite pipeline designer to make changes\n"
        preamble += f"# Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        preamble += f"#**************************************************************************\n\n"
        return preamble

    def _add_required_imports(self):
        """Add required import statements based on component types."""
        # Add imports for compute resources
        self.import_statements.add(
            "from daolite.compute import create_compute_resources"
        )
        
        # ALWAYS add hardware import - it's required for standard compute resources
        self.import_statements.add(
            "from daolite.compute import hardware"
        )
        
        # Track which camera functions are used
        used_camera_funcs = set()
        for component in self.components:
            if component.component_type == ComponentType.CAMERA:
                camera_func = component.params.get("camera_function", "PCOCamLink")
                used_camera_funcs.add(camera_func)
                
        if used_camera_funcs:
            cam_imports = ", ".join(sorted(used_camera_funcs))
            self.import_statements.add(
                f"from daolite.simulation.camera import {cam_imports}"
            )

        # Remove any import of simulate_camera_readout
        self.import_statements = {
            imp
            for imp in self.import_statements
            if "simulate_camera_readout" not in imp
        }

        # Check for component types and add relevant imports
        has_network = False
        for component in self.components:
            # Add component-specific imports
            if component.component_type == ComponentType.CENTROIDER:
                self.import_statements.add(
                    "from daolite.pipeline.centroider import Centroider"
                )

            elif component.component_type == ComponentType.RECONSTRUCTION:
                self.import_statements.add(
                    "from daolite.pipeline.reconstruction import Reconstruction"
                )

            elif component.component_type == ComponentType.CONTROL:
                self.import_statements.add(
                    "from daolite.pipeline.control import FullFrameControl"
                )

            elif component.component_type == ComponentType.CALIBRATION:
                self.import_statements.add(
                    "from daolite.pipeline.calibration import PixelCalibration"
                )

            elif component.component_type == ComponentType.NETWORK:
                has_network = True

        # For visualization
        self.import_statements.add("import matplotlib.pyplot as plt")

        # Only import network_transfer if it exists in network.py
        if has_network:
            try:
                import os

                network_path = os.path.join(
                    os.path.dirname(__file__), "../../utils/network.py"
                )
                with open(network_path, "r") as f:
                    network_code = f.read()
                if "network_transfer" in network_code:
                    self.import_statements.add(
                        "from daolite.utils.network import network_transfer"
                    )
                if "TimeOnNetwork" in network_code:
                    self.import_statements.add(
                        "from daolite.utils.network import TimeOnNetwork"
                    )
            except Exception:
                pass

    def _generate_component_code(self, component: ComponentBlock) -> str:
        """
        Generate code for a specific component.

        Args:
            component: Component block to generate code for

        Returns:
            str: Python code for adding this component to the pipeline
        """
        lines = []

        # Skip generating code for synthetic components that aren't meant to be in the output
        if hasattr(component, '_is_synthetic') and component._is_synthetic:
            return ""

        # Check if this is a transfer component created by the designer
        is_transfer = False
        transfer_data = None
        # Special handling for generated transfer components
        if (component.component_type == ComponentType.NETWORK and 
            component.name.startswith(("Network_Transfer_", "PCIe_Transfer_"))):
            is_transfer = True
            # Find this component in our generated transfer list
            for transfer in self.generated_transfer_components:
                if transfer["name"] == component.name:
                    transfer_data = transfer
                    break

        # Add comment
        lines.append(
            f"# Add {component.name} component ({component.component_type.value})"
        )

        # Add component creation code
        lines.append(f"pipeline.add_component(PipelineComponent(")
        lines.append(
            f"    component_type=ComponentType.{component.component_type.name},"
        )
        lines.append(f'    name="{component.name}",')

        # Add compute resource
        compute_resource = component.get_compute_resource()
        if compute_resource:
            # Try to get a readable name for the compute resource
            compute_code = self._get_compute_resource_code(component)
            lines.append(f"    compute={compute_code},")
        else:
            # Use default values for all required arguments
            lines.append(
                "    compute=create_compute_resources("
                "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
                "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
                "network_speed=100e9, time_in_driver=5.0),"
            )

        # Add function name based on component type
        function_name = self._get_function_name_for_component(component)
        # Camera: use selected camera simulation function
        if component.component_type == ComponentType.CAMERA:
            # Use a parameter or default to PCOCamLink
            camera_func = component.params.get("camera_function", "PCOCamLink")
            lines.append(f"    function={camera_func},")
        else:
            lines.append(f"    function={function_name},")

        # Add parameters
        param_lines = self._generate_params_code(component)
        # Insert params block with a trailing comma
        if param_lines:
            # Remove the last '}'
            if param_lines[-1].strip() == "}":
                param_lines[-1] = "},"
            lines.extend([f"    {param_line}" for param_line in param_lines])

        # Add dependencies
        # For generated transfer components, get dependencies from the transfer data
        if is_transfer and transfer_data and "dependencies" in transfer_data:
            dependencies = transfer_data["dependencies"]
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(f"DEBUG: Generated transfer component {component.name} with dependencies from transfer data: {dependencies}")
            else:
                lines.append(f"    dependencies=[]  # No dependencies")
                print(f"DEBUG: Generated transfer component {component.name} with NO dependencies from transfer data")
        else:
            dependencies = self._get_component_dependencies(component)
            if dependencies:
                deps_str = ", ".join([f'"{dep}"' for dep in dependencies])
                lines.append(f"    dependencies=[{deps_str}]")
                print(f"DEBUG: Generated component {component.name} with dependencies: {dependencies}")
            else:
                lines.append(f"    dependencies=[]  # No dependencies")
                print(f"DEBUG: Generated component {component.name} with NO dependencies")

        # Close the function call
        lines.append("))")

        return "\n".join(lines)

    def _get_function_name_for_component(self, component: ComponentBlock) -> str:
        """Get the appropriate function name based on component type."""
        if component.component_type == ComponentType.CAMERA:
            return "simulate_camera_readout"
        elif component.component_type == ComponentType.CENTROIDER:
            return "Centroider"
        elif component.component_type == ComponentType.RECONSTRUCTION:
            return "Reconstruction"
        elif component.component_type == ComponentType.CONTROL:
            return "FullFrameControl"
        elif component.component_type == ComponentType.CALIBRATION:
            return "PixelCalibration"
        elif component.component_type == ComponentType.NETWORK:
            # Check if this is an auto-generated transfer component
            if hasattr(component, 'params') and 'transfer_type' in component.params:
                transfer_type = component.params['transfer_type'].lower()
                if transfer_type == 'pcie':
                    return "pcie_transfer"
                elif transfer_type == 'network':
                    return "network_transfer"
            # Default to TimeOnNetwork for user-created network components
            return "TimeOnNetwork"
        else:
            return "unknown_function"  # Default

    def _get_compute_resource_code(self, component: ComponentBlock) -> str:
        """
        Get code for the component's compute resource.
        
        Args:
            component: The component block
            
        Returns:
            str: Python code for the compute resource
        """
        compute_resource = component.get_compute_resource()
        if compute_resource:
            c = compute_resource
            resource_name = getattr(c, 'name', '').lower() if hasattr(c, 'name') else ''
            # Use new hardware resource loader: check for YAML-based hardware resource
            import os
            hardware_dir = os.path.join(os.path.dirname(__file__), '../../compute/hardware')
            if resource_name:
                yaml_path = os.path.join(hardware_dir, f'{resource_name}.yaml')
                if os.path.exists(yaml_path):
                    self.import_statements.add("from daolite.compute import hardware")
                    return f"hardware.{resource_name}()"
            # Fallback to explicit resource fields if not a known YAML hardware
            return (
                f"create_compute_resources("
                f"cores={getattr(c, 'cores', 16)}, "
                f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                f"memory_width={getattr(c, 'memory_width', 64)}, "
                f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
            )
        # Try to get parent container compute resource
        parent = getattr(component, 'parentItem', lambda: None)()
        if parent and hasattr(parent, 'get_compute_resource'):
            c = parent.get_compute_resource()
            if c:
                resource_name = getattr(c, 'name', '').lower() if hasattr(c, 'name') else ''
                import os
                hardware_dir = os.path.join(os.path.dirname(__file__), '../../compute/hardware')
                if resource_name:
                    yaml_path = os.path.join(hardware_dir, f'{resource_name}.yaml')
                    if os.path.exists(yaml_path):
                        self.import_statements.add("from daolite.compute import hardware")
                        return f"hardware.{resource_name}()"
                return (
                    f"create_compute_resources("
                    f"cores={getattr(c, 'cores', 16)}, "
                    f"core_frequency={getattr(c, 'core_frequency', 2.6e9)}, "
                    f"flops_per_cycle={getattr(c, 'flops_per_cycle', 32)}, "
                    f"memory_frequency={getattr(c, 'memory_frequency', 3.2e9)}, "
                    f"memory_width={getattr(c, 'memory_width', 64)}, "
                    f"memory_channels={getattr(c, 'memory_channels', 8)}, "
                    f"network_speed={getattr(c, 'network_speed', 100e9)}, "
                    f"time_in_driver={getattr(c, 'time_in_driver', 5.0)})"
                )
        # Fallback to default
        return (
            "create_compute_resources("
            "cores=16, core_frequency=2.6e9, flops_per_cycle=32, "
            "memory_frequency=3.2e9, memory_width=64, memory_channels=8, "
            "network_speed=100e9, time_in_driver=5.0)"
        )

    def _generate_params_code(self, component: ComponentBlock) -> List[str]:
        lines = []
        lines.append("params={")
        # --- Use json_runner.py logic for parameter defaults ---
        # CAMERA
        if component.component_type == ComponentType.CAMERA:
            camera_func = component.params.get("camera_function", "PCOCamLink")
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP camera')
            lines.append(f'    "group": {group},  # Default packet count (was group_size)')
        # CALIBRATION
        elif component.component_type == ComponentType.CALIBRATION:
            n_pixels = component.params.get("n_pixels", 1024 * 1024)
            group = component.params.get("group", 50)
            lines.append(f'    "n_pixels": {n_pixels},  # 1MP sensor')
            lines.append(f'    "group": {group},  # Default group size')
        # CENTROIDER
        elif component.component_type == ComponentType.CENTROIDER:
            n_valid_subaps = component.params.get("n_valid_subaps", 6400)
            n_pix_per_subap = component.params.get("n_pix_per_subap", 16)
            group = component.params.get("group", 50)
            lines.append(f'    "n_valid_subaps": {n_valid_subaps},  # 80x80')
            lines.append(f'    "n_pix_per_subap": {n_pix_per_subap},  # 16 pixels per subap')
            lines.append(f'    "group": {group},  # Default group size')
        # Add custom parameters from component, skipping those already added
        already = {"n_pixels", "group", "n_valid_subaps", "n_pix_per_subap"}
        for key, value in component.params.items():
            if key in already:
                continue
            if isinstance(value, str):
                lines.append(f'    "{key}": "{value}",')
            else:
                lines.append(f'    "{key}": {value},')
        lines.append("}")
        return lines

    def _sort_components_by_dependencies(self) -> List[ComponentBlock]:
        """
        Sort components in dependency order.

        Returns a list of components where all dependencies come before
        the components that depend on them. Also includes auto-generated transfer components
        at the appropriate places in the dependency chain.

        Returns:
            List[ComponentBlock]: Sorted components including transfer components
        """
        # Create a name-to-component mapping
        comp_map = {comp.name: comp for comp in self.components}
        
        # Create synthetic ComponentBlock objects for all transfer components
        transfer_blocks = []
        for transfer in self.generated_transfer_components:
            # Create a synthetic ComponentBlock for the transfer
            transfer_block = ComponentBlock(
                ComponentType.NETWORK,
                transfer["name"]
            )
            # Set parameters from the transfer dict
            transfer_block.params = transfer["params"].copy()
            # Set dependencies to include the source component
            src_comp = transfer["src_comp"]
            dest_comp = transfer["dest_comp"]
            
            # Transfer depends on source component - ALWAYS include this dependency
            if "dependencies" in transfer and src_comp.name not in transfer["dependencies"]:
                transfer["dependencies"].append(src_comp.name)
            
            # Ensure the transfer block has the dependency
            transfer_block._dependencies = [src_comp.name]
            
            # Add to the mapping - this will be used for dependency resolution
            comp_map[transfer_block.name] = transfer_block
            transfer_blocks.append(transfer_block)
            
            # Update destination component's dependencies to include this transfer
            # in the dependency graph (not in the actual component)
            if dest_comp.name in comp_map:
                # Create modified dependencies to replace source with transfer
                if not hasattr(dest_comp, '_modified_dependencies'):
                    # Start with original dependencies
                    dest_comp._modified_dependencies = dest_comp.get_dependencies().copy()
                    
                # Replace direct dependency on source with dependency on transfer
                if src_comp.name in dest_comp._modified_dependencies:
                    dest_comp._modified_dependencies.remove(src_comp.name)
                    dest_comp._modified_dependencies.append(transfer_block.name)
                else:
                    # If dest doesn't have explicit dependency on source, add dependency on transfer
                    # This handles case where UI doesn't show the dependency but code needs it
                    dest_comp._modified_dependencies.append(transfer_block.name)
        
        # Build the dependency graph
        graph = {}
        for comp in list(self.components) + transfer_blocks:
            # Use modified dependencies if available (these account for transfer components)
            if hasattr(comp, '_modified_dependencies'):
                graph[comp.name] = set(comp._modified_dependencies)
            else:
                graph[comp.name] = set(comp.get_dependencies())
        
        # Find components with no dependencies
        no_deps = [name for name, deps in graph.items() if not deps]
        sorted_names = []

        # Topological sort
        while no_deps:
            name = no_deps.pop(0)
            sorted_names.append(name)

            # Find all components that depend on this one
            for dep_name, deps in list(graph.items()):
                if name in deps:
                    deps.remove(name)
                    # If no more dependencies, add to no_deps
                    if not deps and dep_name not in sorted_names:
                        no_deps.append(dep_name)

        # Check for circular dependencies
        if len(sorted_names) < len(graph):
            # Some components couldn't be sorted
            # Add remaining components in any order
            remaining = set(comp_map.keys()) - set(sorted_names)
            sorted_names.extend(remaining)

        # Convert back to component objects
        sorted_components = []
        for name in sorted_names:
            if name in comp_map:
                sorted_components.append(comp_map[name])
                
        return sorted_components

    def export_to_file(self, filename: str):
        """
        Export generated code to a Python file.

        Args:
            filename: Path to output file
        """
        code = self.generate_code()

        with open(filename, "w") as f:
            f.write(code)

    def _add_transfer_components(self):
        """
        Analyze component connections and add appropriate transfer components
        when connections cross different compute resources.
        """
        # Get connections between components
        connections = []
        for src_comp in self.components:
            for port in src_comp.output_ports:
                for dest_comp, _ in port.connected_to:
                    connections.append((src_comp, dest_comp))
        
        # Analyze each connection for resource boundaries
        for src_comp, dest_comp in connections:
            # SPECIAL CASE: Always add network transfer for camera components
            if src_comp.component_type == ComponentType.CAMERA:
                transfer_type = "Network"
                transfer_comp = self._create_transfer_component(src_comp, dest_comp, transfer_type)
                self.generated_transfer_components.append(transfer_comp)
                continue
                
            # Normal case: check for different compute resources
            src_res = src_comp.get_compute_resource()
            dest_res = dest_comp.get_compute_resource()
            
            # Skip if either component has no compute resource
            if not src_res or not dest_res:
                continue
                
            # Skip if same compute resource
            if src_res is dest_res:
                continue
                
            # Determine transfer type based on resource types
            transfer_type = self._determine_transfer_type(src_comp, dest_comp)
            
            if transfer_type:
                # Create a transfer component
                transfer_comp = self._create_transfer_component(src_comp, dest_comp, transfer_type)
                self.generated_transfer_components.append(transfer_comp)
    
    def _determine_transfer_type(self, src_comp: ComponentBlock, dest_comp: ComponentBlock) -> Optional[str]:
        """
        Determine the type of transfer needed between two components.
        
        Args:
            src_comp: Source component
            dest_comp: Destination component
            
        Returns:
            str: "PCIe" for CPU-GPU transfers, "Network" for network transfers, None if same resource
        """
        # SPECIAL CASE: Camera components always connect via network to compute components
        if src_comp.component_type == ComponentType.CAMERA:
            return "Network"
        
        src_res = src_comp.get_compute_resource()
        dest_res = dest_comp.get_compute_resource()
        
        if not src_res or not dest_res:
            return None
            
        # Get parent containers to determine resource types
        src_parent = src_comp.parentItem()
        dest_parent = dest_comp.parentItem()
        
        # If parents are different computers, it's a network transfer
        if src_parent and dest_parent and src_parent != dest_parent:
            from .components import ComputeBox
            if isinstance(src_parent, ComputeBox) and isinstance(dest_parent, ComputeBox):
                return "Network"
        
        # Check for CPU-GPU transfer
        src_is_gpu = getattr(src_res, 'hardware', '').lower() == 'gpu'
        dest_is_gpu = getattr(dest_res, 'hardware', '').lower() == 'gpu'
        
        if src_is_gpu != dest_is_gpu:
            return "PCIe"
            
        return None
    
    def _create_transfer_component(self, src_comp: ComponentBlock, dest_comp: ComponentBlock, 
                                transfer_type: str) -> dict:
        """
        Create a transfer component between two components.
        
        Args:
            src_comp: Source component
            dest_comp: Destination component
            transfer_type: "PCIe" or "Network"
            
        Returns:
            dict: Dictionary representing the transfer component
        """
        # Add network/PCIe imports
        if transfer_type == "Network":
            self.import_statements.add("from daolite.utils.network import network_transfer")
        else:  # PCIe
            self.import_statements.add("from daolite.utils.network import pcie_transfer")
        
        # Determine data size based on source and destination components
        data_size = self._estimate_data_size(src_comp, dest_comp)
        
        # Create a synthetic component with appropriate data
        transfer_name = f"{transfer_type}_Transfer_{src_comp.name}_to_{dest_comp.name}"
        
        print(f"DEBUG: Creating transfer component {transfer_name} from {src_comp.name} to {dest_comp.name}")
        
        # Create component dict with all necessary information
        params = {
            "n_bits": data_size,
            "transfer_type": transfer_type.lower(),
        }
        # Use json_runner.py logic for network transfer params
        if transfer_type == "Network":
            params["group"] = src_comp.params.get("group", src_comp.params.get("group_size", 50))
            dest_compute = dest_comp.get_compute_resource()
            if dest_compute:
                params["use_dest_network"] = True
                params["dest_network_speed"] = getattr(dest_compute, 'network_speed', 100e9)
                params["dest_time_in_driver"] = getattr(dest_compute, 'time_in_driver', 5.0)
        transfer_comp = {
            "name": transfer_name,
            "type": ComponentType.NETWORK,
            "src_comp": src_comp,
            "dest_comp": dest_comp,
            "transfer_type": transfer_type,
            "data_size": data_size,
            "params": params,
            "dependencies": [src_comp.name]
        }
        
        print(f"DEBUG: Transfer {transfer_name} dependencies set to: {transfer_comp['dependencies']}")
        
        # SPECIAL CASE: For camera components, use the destination compute's network characteristics
        # since camera is just a generator and the compute component defines the network properties
        if src_comp.component_type == ComponentType.CAMERA and transfer_type == "Network":
            dest_compute = dest_comp.get_compute_resource()
            if dest_compute:
                # Add extra parameters to use the destination compute's network speed
                transfer_comp["params"]["use_dest_network"] = True
                transfer_comp["params"]["dest_network_speed"] = getattr(dest_compute, 'network_speed', 100e9)
                transfer_comp["params"]["dest_time_in_driver"] = getattr(dest_compute, 'time_in_driver', 5.0)
                
                # For camera-to-calibration pipelines, ensure group size is passed through
                # This is needed for timing array propagation
                if dest_comp.component_type == ComponentType.CALIBRATION:
                    # Get group size from camera or use default
                    group_size = src_comp.params.get("group", src_comp.params.get("group_size", 50))
                    transfer_comp["params"]["group"] = group_size
        
        # Update destination component dependencies to include this transfer
        for port in dest_comp.input_ports:
            for i, (comp, port2) in enumerate(port.connected_to):
                if comp == src_comp:
                    # Replace direct dependency with transfer component
                    port.connected_to[i] = (src_comp, port2)  # Keep the same, just for tracking
        
        return transfer_comp
    
    def _estimate_data_size(self, src_comp: ComponentBlock, dest_comp: ComponentBlock) -> int:
        """
        Estimate the data size transferred between components based on their types.
        
        Args:
            src_comp: Source component
            dest_comp: Destination component
            
        Returns:
            int: Estimated data size in bits
        """
        # Default size
        data_size = 1024 * 1024 * 8  # 1MB in bits
        
        # Estimate based on source component type
        if src_comp.component_type == ComponentType.CAMERA:
            # Camera typically outputs pixel data
            n_pixels = src_comp.params.get("n_pixels", 1024 * 1024)
            data_size = n_pixels * 16  # 16 bits per pixel
            
        elif src_comp.component_type == ComponentType.CENTROIDER:
            # Centroider outputs slopes
            n_subaps = src_comp.params.get("n_subaps", 5120)
            data_size = n_subaps * 2 * 32  # X and Y slopes, 32 bits per value
            
        elif src_comp.component_type == ComponentType.RECONSTRUCTION:
            # Reconstruction outputs actuator commands
            n_actuators = src_comp.params.get("n_actuators", 5000)
            data_size = n_actuators * 32  # 32 bits per actuator
            
        # Estimate based on destination component if source estimation failed
        if data_size <= 0:
            if dest_comp.component_type == ComponentType.CENTROIDER:
                n_pixels = dest_comp.params.get("n_subaps", 5120) * dest_comp.params.get("pixels_per_subap", 256)
                data_size = n_pixels * 16  # 16 bits per pixel
                
            elif dest_comp.component_type == ComponentType.RECONSTRUCTION:
                n_slopes = dest_comp.params.get("n_slopes", 5120 * 2)
                data_size = n_slopes * 32  # 32 bits per slope
                
            elif dest_comp.component_type == ComponentType.CONTROL:
                n_actuators = dest_comp.params.get("n_actuators", 5000)
                data_size = n_actuators * 32  # 32 bits per actuator
        
        return max(data_size, 1024)  # Ensure minimum data size

    def _get_component_dependencies(self, component: ComponentBlock) -> List[str]:
        """
        Get the component's dependencies, taking into account network transfers.
        
        This method handles the modified dependency graph created for transfer components.
        
        Args:
            component: The component to get dependencies for
            
        Returns:
            List[str]: List of component names that this component depends on
        """
        # Use modified dependencies if available (these account for transfer components)
        if hasattr(component, '_modified_dependencies'):
            return component._modified_dependencies
            
        # Find if this component is a destination of any transfer
        for transfer in self.generated_transfer_components:
            if transfer["dest_comp"] == component:
                # This component should depend on the transfer, not the original source
                deps = component.get_dependencies().copy()
                src_comp = transfer["src_comp"]
                transfer_name = transfer["name"]
                
                # Replace source dependency with transfer dependency
                if src_comp.name in deps:
                    deps.remove(src_comp.name)
                    deps.append(transfer_name)
                else:
                    # Special case: Camera connections may not have explicit dependencies
                    # but still need the transfer component in the dependency chain
                    if src_comp.component_type == ComponentType.CAMERA:
                        deps.append(transfer_name)
                        
                return deps
                
        # Regular case: use the component's normal dependencies
        return component.get_dependencies()
